import { supabase } from './supabaseClient'
import { getCurrentUser } from './authService'

/**
 * –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @param {number} chapterId - ID –≥–ª–∞–≤—ã
 * @param {number} sectionId - ID —Ä–∞–∑–¥–µ–ª–∞
 * @param {number} questionId - ID –≤–æ–ø—Ä–æ—Å–∞
 * @param {boolean} isCorrect - –ü—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–∞
 * @param {string|string[]} selectedAnswer - –í—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç
 * @param {number} timeSpent - –í—Ä–µ–º—è –Ω–∞ –æ—Ç–≤–µ—Ç (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)
 * @param {number} hintsUsed - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–¥—Å–∫–∞–∑–æ–∫
 * @returns {Promise<Object>} –°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç
 */
export async function saveProgress({
  chapterId,
  sectionId,
  questionId,
  selectedAnswer,
  isCorrect,
  timeSpent = 0,
  hintsUsed = 0
}: {
  chapterId: number
  sectionId: number
  questionId: number | null
  selectedAnswer: string | string[]
  isCorrect: boolean
  timeSpent?: number
  hintsUsed?: number
}): Promise<any> {
  try {
    const currentUser = await getCurrentUser()
    const userId = Array.isArray(currentUser?.id)
      ? currentUser?.id[0]
      : currentUser?.id
    if (!userId) {
      console.warn('userId not available')
      return null
    }

    // ‚úÖ –°–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –∑–∞–ø–∏—Å—å (–µ—Å–ª–∏ –µ—Å—Ç—å)
    const { data: existing, error: fetchError } = await supabase
      .from('user_progress')
      .select('*')
      .eq('user_id', userId)
      .eq('section_id', sectionId)
      .limit(1)
      .single()

    if (fetchError && fetchError.code !== 'PGRST116') {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:', fetchError)
      return null
    }

    // üí° –†–µ—à–∞–µ–º: –Ω—É–∂–Ω–æ –ª–∏ –æ–±–Ω–æ–≤–ª—è—Ç—å –∑–∞–ø–∏—Å—å
    const shouldUpdate =
      !existing ||
      (existing && isCorrect && !existing.is_correct) ||
      (existing && isCorrect && timeSpent < (existing.time_spent ?? 0))

    if (!shouldUpdate) {
      console.log('‚è© –ü—Ä–æ–≥—Ä–µ—Å—Å –Ω–µ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è: —Ç–µ–∫—É—â–∞—è –ø–æ–ø—ã—Ç–∫–∞ –Ω–µ –ª—É—á—à–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–π')
      return existing
    }

    // üÜï –í—Å—Ç–∞–≤–∫–∞ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ –∫–ª—é—á—É user_id + section_id
    const answerString: string = Array.isArray(selectedAnswer)
      ? selectedAnswer.join(', ')
      : String(selectedAnswer)

    const { data, error } = await supabase
      .from('user_progress')
      .upsert(
        [
          {
            user_id: userId,
            chapter_id: chapterId,
            section_id: sectionId,
            question_id: questionId,
            selected_answer: answerString,
            is_correct: isCorrect,
            time_spent: timeSpent,
            hints_used: hintsUsed,
            answered_at: new Date().toISOString()
          } as any
        ],
        {
          onConflict: 'user_id, section_id'
        }
      )

    if (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ upsert –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:', error)
    }

    return data
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –≤ saveProgress:', err)
    return null
  }
}

// –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
export const saveAnswer = saveProgress

export interface BulkAnswer {
  questionId: number | null
  selectedAnswer: string | string[]
  isCorrect: boolean
  timeSpent?: number
  hintsUsed?: number
}

/**
 * –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –æ—Ç–≤–µ—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Ä–∞–∑–æ–º
 */
export async function saveProgressBulk(
  chapterId: number,
  sectionId: number,
  answers: BulkAnswer[]
): Promise<any> {
  try {
    const currentUser = await getCurrentUser()
    const userId = Array.isArray(currentUser?.id)
      ? currentUser?.id[0]
      : currentUser?.id
    if (!userId) {
      console.warn('userId not available')
      return null
    }

    if (!answers.length) return null

    const rows = answers.map(a => ({
      user_id: userId,
      chapter_id: chapterId,
      section_id: sectionId,
      question_id: a.questionId,
      selected_answer: Array.isArray(a.selectedAnswer)
        ? a.selectedAnswer.join(', ')
        : String(a.selectedAnswer),
      is_correct: a.isCorrect,
      time_spent: a.timeSpent ?? 0,
      hints_used: a.hintsUsed ?? 0,
      answered_at: new Date().toISOString()
    })) as any[]

    const { data, error } = await supabase
      .from('user_progress')
      .upsert(rows, { onConflict: 'user_id, question_id' })

    if (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ bulk upsert –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:', error)
    }

    return data
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –≤ saveProgressBulk:', err)
    return null
  }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å –≤–µ—Å—å –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns {Promise<Array>} –ú–∞—Å—Å–∏–≤ –æ—Ç–≤–µ—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export async function getUserProgress(): Promise<any[]> {
  try {
    const user = await getCurrentUser()
    if (!user) return []

    const { data, error } = await supabase
      .from('user_progress')
      .select('*')
      .eq('user_id', user.id)
      .order('answered_at', { ascending: false })

    if (error) throw error

    return data || []
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:', error.message)
    return []
  }
}

// –ü–æ–ª—É—á–∏—Ç—å –ø–æ–¥—Ä–æ–±–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ —Ä–∞–∑–¥–µ–ª–∞–º –∏ –≥–ª–∞–≤–∞–º
export async function getFullUserProgress(userId: string): Promise<any[]> {
  try {
    const { data, error } = await supabase
      .from('user_progress')
      .select(`
        chapter_id,
        section_id,
        is_correct,
        time_spent,
        answered_at,
        hints_used
      `)
      .eq('user_id', userId)

    if (error) {
      console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:', error.message)
      return []
    }

    return data
  } catch (e: any) {
    console.error('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:', e.message)
    return []
  }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –≥–ª–∞–≤–µ
 * @param {number} chapterId - ID –≥–ª–∞–≤—ã
 * @returns {Promise<Array>} –ü—Ä–æ–≥—Ä–µ—Å—Å –ø–æ –≥–ª–∞–≤–µ
 */
export async function getChapterProgress(chapterId: number): Promise<any[]> {
  try {
    const user = await getCurrentUser()
    if (!user) return []

    const { data, error } = await supabase
      .from('user_progress')
      .select('*')
      .eq('user_id', user.id)
      .eq('chapter_id', chapterId)
      .order('answered_at', { ascending: false })

    if (error) throw error

    return data || []
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –≥–ª–∞–≤—ã:', error.message)
    return []
  }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É —Ä–∞–∑–¥–µ–ª—É
 * @param {number} chapterId - ID –≥–ª–∞–≤—ã
 * @param {number} sectionId - ID —Ä–∞–∑–¥–µ–ª–∞
 * @returns {Promise<Array>} –ü—Ä–æ–≥—Ä–µ—Å—Å –ø–æ —Ä–∞–∑–¥–µ–ª—É
 */
export async function getSectionProgress(
  chapterId: number,
  sectionId: number
): Promise<any[]> {
  try {
    const user = await getCurrentUser()
    if (!user) return []

    const { data, error } = await supabase
      .from('user_progress')
      .select('*')
      .eq('user_id', user.id)
      .eq('chapter_id', chapterId)
      .eq('section_id', sectionId)
      .order('answered_at', { ascending: false })

    if (error) throw error

    return data || []
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Ä–∞–∑–¥–µ–ª–∞:', error.message)
    return []
  }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è —Ä–∞–∑–¥–µ–ª–∞
 * @param {number} chapterId - ID –≥–ª–∞–≤—ã
 * @param {number} sectionId - ID —Ä–∞–∑–¥–µ–ª–∞
 * @returns {Promise<number>} –ü—Ä–æ—Ü–µ–Ω—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
 */
export async function getSectionProgressPercent(
  chapterId: number,
  sectionId: number
): Promise<number> {
  try {
    const user = await getCurrentUser()
    if (!user) return 0

    const { count: answeredCount, error: progressError } = await supabase
      .from('user_progress')
      .select('question_id', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .eq('chapter_id', chapterId)
      .eq('section_id', sectionId)

    if (progressError) throw progressError

    const { count: totalQuestions, error: questionsError } = await supabase
      .from('questions')
      .select('id', { count: 'exact', head: true })
      .eq('section_id', sectionId)

    if (questionsError) throw questionsError

    if (!totalQuestions || totalQuestions === 0) return 0

    return Math.round(((answeredCount || 0) / totalQuestions) * 100)
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ—Ü–µ–Ω—Ç–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Ä–∞–∑–¥–µ–ª–∞:', error.message)
    return 0
  }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è –≥–ª–∞–≤—ã
 * @param {number} chapterId - ID –≥–ª–∞–≤—ã
 * @returns {Promise<number>} –ü—Ä–æ—Ü–µ–Ω—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
 */
export async function getChapterProgressPercent(chapterId: number): Promise<number> {
  try {
    const user = await getCurrentUser()
    if (!user) return 0

    const { data: sections, error: sectionsError } = await supabase
      .from('sections')
      .select('id')
      .eq('chapter_id', chapterId)

    if (sectionsError) throw sectionsError

    const totalSections = sections ? sections.length : 0
    if (totalSections === 0) return 0

    const { data: completed, error: progressError } = await supabase
      .from('user_progress')
      .select('section_id')
      .eq('user_id', user.id)
      .eq('chapter_id', chapterId)

    if (progressError) throw progressError

    const completedCount = completed ? new Set(completed.map(p => p.section_id)).size : 0

    return Math.round((completedCount / totalSections) * 100)
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ—Ü–µ–Ω—Ç–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –≥–ª–∞–≤—ã:', error.message)
    return 0
  }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –ø–æ –≤—Å–µ–º –≥–ª–∞–≤–∞–º –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns {Promise<Record<number, number>>} –ö–ª—é—á - ID –≥–ª–∞–≤—ã, –∑–Ω–∞—á–µ–Ω–∏–µ - –ø—Ä–æ—Ü–µ–Ω—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
 */
export async function getAllChaptersProgressPercent(): Promise<Record<number, number>> {
  try {
    const user = await getCurrentUser()
    if (!user) return {}

    const { data: sections, error: sectionsError } = await supabase
      .from('sections')
      .select('id, chapter_id')

    if (sectionsError || !sections) throw sectionsError

    const { data: progress, error: progressError } = await supabase
      .from('user_progress')
      .select('section_id, chapter_id')
      .eq('user_id', user.id)

    if (progressError || !progress) throw progressError

    const totalByChapter: Record<number, number> = {}
    sections.forEach(sec => {
      totalByChapter[sec.chapter_id] = (totalByChapter[sec.chapter_id] || 0) + 1
    })

    const completedByChapter: Record<number, Set<number>> = {}
    progress.forEach(row => {
      const ch = row.chapter_id
      if (row.section_id == null) return
      if (!completedByChapter[ch]) completedByChapter[ch] = new Set<number>()
      completedByChapter[ch].add(row.section_id)
    })

    const result: Record<number, number> = {}
    Object.entries(totalByChapter).forEach(([chapterIdStr, total]) => {
      const chId = Number(chapterIdStr)
      const completed = completedByChapter[chId] ? completedByChapter[chId].size : 0
      result[chId] = total > 0 ? Math.round((completed / total) * 100) : 0
    })

    return result
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –ø–æ –≤—Å–µ–º –≥–ª–∞–≤–∞–º:', error.message)
    return {}
  }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns {Promise<Object>} –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export async function getUserStats(): Promise<any> {
  try {
    const user = await getCurrentUser()
    if (!user) return getDefaultStats()

    const progress = await getUserProgress()
    
    const totalAnswers = progress.length
    const correctAnswers = progress.filter(p => p.is_correct).length
    const totalTimeSpent = progress.reduce((sum, p) => sum + (p.time_spent || 0), 0)
    const totalHintsUsed = progress.reduce((sum, p) => sum + (p.hints_used || 0), 0)
    
    // –ü–æ–¥—Å—á–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –≥–ª–∞–≤ –∏ —Ä–∞–∑–¥–µ–ª–æ–≤
    const completedSections = new Set()
    const completedChapters = new Set()
    
    progress.forEach(p => {
      const sectionKey = `${p.chapter_id}-${p.section_id}`
      completedSections.add(sectionKey)
      completedChapters.add(p.chapter_id)
    })

    const accuracy = totalAnswers > 0 ? Math.round((correctAnswers / totalAnswers) * 100) : 0
    const averageTimePerQuestion = totalAnswers > 0 ? Math.round(totalTimeSpent / totalAnswers) : 0

    return {
      totalAnswers,
      correctAnswers,
      accuracy,
      totalTimeSpent,
      totalHintsUsed,
      averageTimePerQuestion,
      completedSections: completedSections.size,
      completedChapters: completedChapters.size,
      level: calculateLevel(accuracy, totalAnswers),
      progress: calculateOverallProgress(completedChapters.size)
    }
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:', error.message)
    return getDefaultStats()
  }
}

/**
 * –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–µ—Å—Ç–∞
 * @param {Object} testResult - –†–µ–∑—É–ª—å—Ç–∞—Ç —Ç–µ—Å—Ç–∞
 * @returns {Promise<Object>} –°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
 */
export async function saveTestResult(testResult: any): Promise<any> {
  try {
    const user = await getCurrentUser()
    if (!user) throw new Error('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω')

    const { data, error } = await supabase
      .from('test_results')
      .insert([
        {
          user_id: user.id,
          test_type: testResult.testType || 'general',
          score: testResult.score,
          total_questions: testResult.totalQuestions,
          correct_answers: testResult.correctAnswers,
          time_spent: testResult.timeSpent,
          section_scores: testResult.sectionScores || {},
          completed_at: new Date().toISOString()
        }
      ])
      .select()
      .single()

    if (error) throw error

    console.log('‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç —Ç–µ—Å—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω')
    return data
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Ç–µ—Å—Ç–∞:', error.message)
    throw new Error(`–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Ç–µ—Å—Ç–∞: ${error.message}`)
  }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns {Promise<Array>} –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–æ–≤
 */
export async function getUserTestResults(): Promise<any[]> {
  try {
    const user = await getCurrentUser()
    if (!user) return []

    const { data, error } = await supabase
      .from('test_results')
      .select('*')
      .eq('user_id', user.id)
      .order('completed_at', { ascending: false })

    if (error) throw error

    return data || []
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–µ—Å—Ç–æ–≤:', error.message)
    return []
  }
}

/**
 * –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è —Ä–∞–∑–¥–µ–ª–∞ –∏ –≤—ã–¥–∞—Ç—å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
 * @param {number} chapterId
 * @param {number} sectionId
 * @param {number} correctAnswers
 * @param {number} totalQuestions
 * @param {number} timeSpent
 * @returns {Promise<Object>} —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏ —Å–ø–∏—Å–æ–∫ –Ω–æ–≤—ã—Ö –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
 */
export async function saveTestResults(
  chapterId: number,
  sectionId: number,
  correctAnswers: number,
  totalQuestions: number,
  timeSpent: number = 0
): Promise<{ result: any; achievements: string[] }> {
  try {
    const user = await getCurrentUser()
    if (!user) throw new Error('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω')

    const score = Math.round((correctAnswers / totalQuestions) * 100)

    const { data, error } = await supabase
      .from('test_results')
      .insert([
        {
          user_id: user.id,
          test_type: 'section',
          correct_answers: correctAnswers,
          total_questions: totalQuestions,
          score: score,
          time_spent: timeSpent,
          completed_at: new Date().toISOString(),
          section_scores: { chapter_id: chapterId, section_id: sectionId, accuracy: score, time: timeSpent }
        }
      ])
      .select()
      .single()

    if (error) throw error

    const achievements = await checkAndAssignAchievements(user.id, sectionId, chapterId, score)

    console.log('‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞–∑–¥–µ–ª–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã')
    return { result: data, achievements }
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ä–∞–∑–¥–µ–ª–∞:', error.message)
    throw new Error(`–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤: ${error.message}`)
  }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns {Promise<Array>}
 */
export async function getUserAchievements(): Promise<any[]> {
  try {
    const user = await getCurrentUser()
    if (!user) return []

    const { data, error } = await supabase
      .from('user_achievements')
      .select('*')
      .eq('user_id', user.id)
      .order('earned_at', { ascending: true })

    if (error) throw error

    return data || []
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π:', error.message)
    return []
  }
}

/**
 * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∏ –Ω–∞–∑–Ω–∞—á–∏—Ç—å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞–∑–¥–µ–ª–∞
 * @param {string} userId
 * @param {number} sectionId
 * @param {number} chapterId
 * @param {number} accuracy
 * @returns {Promise<string[]>} —Å–ø–∏—Å–æ–∫ –Ω–æ–≤—ã—Ö –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
 */
export async function checkAndAssignAchievements(
  userId: string,
  sectionId: number,
  chapterId: number,
  accuracy: number
): Promise<string[]> {
  const earned: string[] = []

  const hasAchievement = async (type: string, extraFilter: any = {}) => {
    let query = supabase
      .from('user_achievements')
      .select('id')
      .eq('user_id', userId)
      .eq('achievement_type', type)

    if (extraFilter.section_id) {
      query = query.filter('achievement_data->>section_id', 'eq', String(extraFilter.section_id))
    }
    if (extraFilter.chapter_id) {
      query = query.filter('achievement_data->>chapter_id', 'eq', String(extraFilter.chapter_id))
    }

    const { data, error } = await query

    if (error) throw error
    return data && data.length > 0
  }

  const insertAchievement = async (type: string, data: any = {}) => {
    const { error } = await supabase.from('user_achievements').insert({
      user_id: userId,
      achievement_type: type,
      achievement_data: data,
      earned_at: new Date().toISOString()
    })
    if (!error) earned.push(type)
  }

  try {
    // section_complete
    if (!(await hasAchievement('section_complete', { section_id: sectionId }))) {
      await insertAchievement('section_complete', { section_id: sectionId, chapter_id: chapterId })
    }

    // first_section
    if (!(await hasAchievement('first_section'))) {
      const { count } = await supabase
        .from('user_achievements')
        .select('id', { count: 'exact', head: true })
        .eq('user_id', userId)
        .eq('achievement_type', 'section_complete')
      if ((count || 0) === 0) {
        await insertAchievement('first_section', { section_id: sectionId, chapter_id: chapterId })
      }
    }

    // chapter_master
    const { data: allSections } = await supabase
      .from('sections')
      .select('id')
      .eq('chapter_id', chapterId)

    const { data: completed } = await supabase
      .from('user_progress')
      .select('distinct section_id')
      .eq('user_id', userId)
      .eq('chapter_id', chapterId)

    if (
      allSections &&
      completed &&
      allSections.length > 0 &&
      completed.length === allSections.length &&
      !(await hasAchievement('chapter_master', { chapter_id: chapterId }))
    ) {
      await insertAchievement('chapter_master', { chapter_id: chapterId })
    }

    // accuracy_90
    if (accuracy >= 90 && !(await hasAchievement('accuracy_90', { section_id: sectionId }))) {
      await insertAchievement('accuracy_90', { section_id: sectionId, chapter_id: chapterId })
    }

    return earned
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π:', error.message)
    return earned
  }
}

/**
 * –°–±—Ä–æ—Å–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns {Promise<void>}
 */
export async function resetUserProgress(): Promise<void> {
  try {
    const user = await getCurrentUser()
    if (!user) throw new Error('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω')

    // –£–¥–∞–ª—è–µ–º –≤—Å–µ –æ—Ç–≤–µ—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const { error: progressError } = await supabase
      .from('user_progress')
      .delete()
      .eq('user_id', user.id)

    if (progressError) throw progressError

    // –£–¥–∞–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–æ–≤
    const { error: testsError } = await supabase
      .from('test_results')
      .delete()
      .eq('user_id', user.id)

    if (testsError) throw testsError

    console.log('‚úÖ –ü—Ä–æ–≥—Ä–µ—Å—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å–±—Ä–æ—à–µ–Ω')
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ —Å–±—Ä–æ—Å–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:', error.message)
    throw new Error(`–û—à–∏–±–∫–∞ —Å–±—Ä–æ—Å–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞: ${error.message}`)
  }
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
function getDefaultStats() {
  return {
    totalAnswers: 0,
    correctAnswers: 0,
    accuracy: 0,
    totalTimeSpent: 0,
    totalHintsUsed: 0,
    averageTimePerQuestion: 0,
    completedSections: 0,
    completedChapters: 0,
    level: '–ù–∞—á–∏–Ω–∞—é—â–∏–π',
    progress: 0
  }
}

function calculateLevel(accuracy: number, totalAnswers: number): string {
  if (totalAnswers < 10) return '–ù–∞—á–∏–Ω–∞—é—â–∏–π'
  if (accuracy >= 90) return '–≠–∫—Å–ø–µ—Ä—Ç'
  if (accuracy >= 80) return '–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π'
  if (accuracy >= 70) return '–°—Ä–µ–¥–Ω–∏–π'
  if (accuracy >= 60) return '–£—á–µ–Ω–∏–∫'
  return '–ù–∞—á–∏–Ω–∞—é—â–∏–π'
}

function calculateOverallProgress(completedChapters: number): number {
  const totalChapters = 14 // –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≥–ª–∞–≤ –≤ –∫—É—Ä—Å–µ
  return Math.round((completedChapters / totalChapters) * 100)
}
